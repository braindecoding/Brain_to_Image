import os
import pickle
import random
import sys

import numpy as np
from keras import backend as K
from keras.datasets import mnist
from keras.layers import Input
from keras.models import Model, Sequential, load_model
from keras.optimizers import Adam
from keras.utils import to_categorical

sys.path.append(os.path.dirname(os.path.dirname((os.path.abspath(__file__)))))
from models.eeggan import (build_EEGgan, build_discriminator,
                            build_generator, sample_images, save_model, combine_loss_metrics)
from utils.local_MNIST import get_balanced_mnist_subset, load_local_mnist


print(os.getcwd())

class_labels = [0,1,2,3,4,5,6,7,8,9]
eeg_encoding_dim = 128

batch_size = 32
epochs = 1501
save_interval = 100
# Adversarial ground truths
valid = np.ones((batch_size, 1))
fake = np.zeros((batch_size, 1))
image_data_dir = "Datasets\MNIST_dataset"
_ , (x_test, y_test) = load_local_mnist(image_data_dir,norm=-1,sparse=True)

optimizer = Adam(0.0002, 0.5)
discrim_losses = ['binary_crossentropy', 'sparse_categorical_crossentropy']  #sparse_
gen_losses = ['categorical_crossentropy']

discriminator = build_discriminator((28,28,1),len(class_labels))
discriminator.compile(loss=discrim_losses, optimizer=optimizer, metrics=['accuracy'])

generator = build_generator(eeg_encoding_dim,x_test.shape[3],len(class_labels))
generator.compile(loss=gen_losses, optimizer=optimizer, metrics=['accuracy'])

noise = Input(shape=(eeg_encoding_dim,))
label = Input(shape=(1,))
img = generator([noise, label])

discriminator.trainable = False
valid_class, target_label = discriminator(img)

#combined = Model([noise, label], [valid_class, target_label])
combined = build_EEGgan(eeg_encoding_dim, len(class_labels), generator, discriminator)
combined.compile(loss=discrim_losses, optimizer=optimizer, metrics=['accuracy'])
history = {'Discriminator':[],'Generator':[]}
for epoch in range(epochs):

    # ---------------------
    #  Train Discriminator: Discriminator is trained using real and generated images with the goal to identify the difference
    # ---------------------
    # Select a random batch of real images with corresponding lables
    idx = np.random.randint(0, x_test.shape[0], batch_size)
    imgs = x_test[idx]
    # Image labels. 0-9
    img_labels = y_test[idx]

    # Sample noise as generator input
    noise = np.random.normal(0, 1, (batch_size, eeg_encoding_dim))
    # The labels of the digits that the generator tries to create an
    # image representation of
    sampled_labels = np.random.randint(0, 10, (batch_size, 1))
    #sampled_lables = to_categorical(sampled_labels,num_classes=len(class_labels),dtype=np.int32)
    # Generate a half batch of new images
    gen_imgs = generator.predict([noise, sampled_labels])

    # Train the discriminator, to recognise real/fake images
    # loss_real : using real images selected from training data
    # loss_fake : using images generated by the generator
    d_loss_real = discriminator.train_on_batch(imgs, [valid, img_labels], return_dict=True)
    d_loss_fake = discriminator.train_on_batch(gen_imgs, [fake, sampled_labels], return_dict=True)
    #d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)
    d_loss = combine_loss_metrics(d_loss_real, d_loss_fake)
    print(d_loss.keys())
    # ---------------------
    #  Train Generator:
    # ---------------------
    # Train the generator using the combined GAN model so that Generator learns to create better images to fool the discriminator
    g_loss = combined.train_on_batch([noise, sampled_labels], [valid, sampled_labels], return_dict=True)
    print(g_loss.keys())
    history['Discriminator'].append(d_loss)
    history['Generator'].append(g_loss)
    # Plot the progress
    print (f"Epoch {epoch:5d}: [D loss: {d_loss['loss']:.6f}, Validity acc.: {d_loss['Dis_Validity_accuracy']:.2%}, Label acc: {d_loss['Dis_Class_Label_accuracy']:.2%}]")
    print(f"             [G loss: {g_loss['loss']:.6f}] [D loss: {g_loss['Discriminator_loss']:.6f}]")

    # If at save interval => save generated image samples
    if epoch % save_interval == 0:
        save_model(generator, f"Generator_{epoch}")
        save_model(discriminator, f"Discriminator_{epoch}")
        eeg_space = np.random.normal(0, 1, (100,eeg_encoding_dim) )
        eeg_lables = np.array([num for _ in range(10) for num in range(10)])
        sample_images(epoch,generator,eeg_encoding_dim,eeg_space,eeg_lables)


with open(f"./brain_to_image/bigan/saved_model/history.pkl","wb") as f:
    pickle.dump(history,f)
#combined.save_weights(f"./brain_to_image/bigan/saved_model/combined_weights.h5")
#generator.save_weights(f"./brain_to_image/bigan/saved_model/generator_weights.h5")
#discriminator.save_weights(f"./brain_to_image/bigan/saved_model/discriminator_weights.h5")
combined.save(f"./brain_to_image/bigan/saved_model/combined_final_model.h5")
generator.save(f"./brain_to_image/bigan/saved_model/generator_final_model.h5")
discriminator.save(f"./brain_to_image/bigan/saved_model/discriminator_model.h5")



pass